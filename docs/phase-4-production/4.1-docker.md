# Docker

Docker packages your application and its dependencies into a container that runs anywhere. Same environment on your laptop, CI server, and production. No more "works on my machine."

## Why This Matters

Deployment is hard. Dependencies conflict. Python versions differ. Configuration varies. Docker solves this by packaging everything into a portable container.

For our job market analyzer, Docker means the same container that runs locally runs in production - no surprises.

## The Key Ideas

### Dockerfile

Defines how to build your container:

```dockerfile
FROM python:3.11-slim
WORKDIR /app

# Install dependencies first (layer caching)
COPY requirements.txt .
RUN pip install -r requirements.txt

# Copy application code
COPY . .

CMD ["python", "main.py"]
```

Build once, run anywhere.

### Docker Commands

```bash
# Build image
docker build -t my-ai-app .

# Run container
docker run -p 8000:8000 --env-file .env my-ai-app

# List containers
docker ps

# View logs
docker logs -f <container-id>
```

### Docker Compose

Orchestrate multiple containers:

```yaml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "8000:8000"
    env_file: .env
    depends_on:
      - postgres
      - redis

  postgres:
    image: ankane/pgvector
    environment:
      POSTGRES_PASSWORD: postgres
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:alpine

volumes:
  postgres_data:
```

Start everything with `docker-compose up -d`.

### The AI Stack

```
┌─────────────────┐
│   FastAPI App   │ :8000
└────────┬────────┘
         │
    ┌────┴────┬────────┐
    │         │        │
┌───▼──┐  ┌──▼───┐  ┌─▼────┐
│Postgres│ │Redis │  │Celery│
│pgvector│ │      │  │Worker│
└───────┘ └──────┘  └──────┘
```

App, database, cache, worker - all in containers.

## What's in This Module

| Script | What it shows |
|--------|---------------|
| <a href="../../modules/Phase%204%20-%20Production%20Systems/4.1-docker/01_dockerfile_basics.py">01_dockerfile_basics.py</a> | Creating Dockerfiles |
| <a href="../../modules/Phase%204%20-%20Production%20Systems/4.1-docker/02_docker_compose.py">02_docker_compose.py</a> | Multi-container orchestration |
| <a href="../../modules/Phase%204%20-%20Production%20Systems/4.1-docker/03_environment_config.py">03_environment_config.py</a> | Managing configuration |
| <a href="../../modules/Phase%204%20-%20Production%20Systems/4.1-docker/Dockerfile">Dockerfile</a> | Production-ready example |
| <a href="../../modules/Phase%204%20-%20Production%20Systems/4.1-docker/docker-compose.yml">docker-compose.yml</a> | Full stack setup |

## Best Practices

### Layer Caching
```dockerfile
# Copy requirements first - changes rarely
COPY requirements.txt .
RUN pip install -r requirements.txt

# Copy code last - changes often
COPY . .
```

Dependencies are cached; only code rebuild is needed.

### Multi-Stage Builds
```dockerfile
# Build stage
FROM python:3.11 AS builder
RUN pip install --user requirements.txt

# Runtime stage
FROM python:3.11-slim
COPY --from=builder /root/.local /root/.local
```

Smaller final images.

### Environment Variables
```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    openai_api_key: str
    database_url: str
    class Config:
        env_file = ".env"
```

Never hardcode secrets.

### Health Checks
```dockerfile
HEALTHCHECK --interval=30s --timeout=3s \
  CMD curl -f http://localhost:8000/health || exit 1
```

Container orchestrators use this to manage restarts.

## Common Issues

### Services Can't Connect
Use service names, not localhost:
```python
# Inside container
DATABASE_URL = "postgresql://user:pass@postgres:5432/db"
# Not localhost!
```

### Out of Memory
Set resource limits:
```yaml
services:
  app:
    mem_limit: 2g
    mem_reservation: 1g
```

### Slow Builds
Enable BuildKit:
```bash
DOCKER_BUILDKIT=1 docker build -t my-app .
```

## Things to Think About

- **When do you need Docker?** When you want reproducible deployments, consistent environments, or easy scaling.
- **Docker vs virtual environments?** Docker is more isolated. Use Docker for deployment, venv for development.
- **How do you handle secrets?** Environment variables, not baked into images. Use .env files locally, secret managers in production.

## Related

- <a href="../phase-3-advanced-patterns/3.6-fastapi-basics.md">FastAPI Basics</a> - What goes in the container
- <a href="./4.2-postgresql-pgvector.md">PostgreSQL + pgvector</a> - Database container
- <a href="./4.7-cloud-deployment.md">Cloud Deployment</a> - Running containers in the cloud

## Book References

- AI_eng.10 - Deployment considerations
