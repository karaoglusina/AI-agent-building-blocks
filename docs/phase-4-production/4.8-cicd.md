# CI/CD

Continuous Integration and Continuous Deployment automate the path from code to production. Push changes, tests run, code deploys. No manual steps, no forgotten procedures.

## Why This Matters

Manual deployment is error-prone. You forget to run tests. You deploy the wrong branch. You misconfigure something. CI/CD makes deployment boring and reliable.

For our job market analyzer, CI/CD means every push to main runs tests, and every passing build deploys automatically.

## The Key Ideas

### GitHub Actions

Define workflows in YAML:

```yaml
# .github/workflows/ci.yml
name: CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install -e ".[dev]"

      - name: Run tests
        run: pytest
```

Runs on every push. Fails if tests fail.

### Automated Testing

Test on every change:

```yaml
jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: ankane/pgvector
        env:
          POSTGRES_PASSWORD: postgres
        ports:
          - 5432:5432

    steps:
      - uses: actions/checkout@v4
      - name: Run tests
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test
        run: pytest
```

Tests run with real dependencies.

### Deploy on Merge

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Deploy to server
        env:
          SSH_KEY: ${{ secrets.SSH_KEY }}
        run: |
          echo "$SSH_KEY" > key
          chmod 600 key
          ssh -i key user@server "cd app && git pull && docker-compose up -d --build"
```

Merge to main → automatic deployment.

### Secrets Management

Store sensitive values in GitHub Secrets:

```yaml
env:
  OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
  DATABASE_URL: ${{ secrets.DATABASE_URL }}
```

Never commit secrets to code.

### Build and Push Docker

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          push: true
          tags: myregistry/myapp:latest
```

Build images in CI, push to registry.

## What's in This Module

| File | What it shows |
|------|---------------|
| [01_github_actions.yml](../../modules/Phase%204%20-%20Production%20Systems/4.8-cicd/01_github_actions.yml) | Basic CI workflow |
| [02_automated_tests.yml](../../modules/Phase%204%20-%20Production%20Systems/4.8-cicd/02_automated_tests.yml) | Run tests with services |
| [03_deploy_workflow.yml](../../modules/Phase%204%20-%20Production%20Systems/4.8-cicd/03_deploy_workflow.yml) | Deploy on merge to main |

## Workflow Structure

```
Push → Test → Build → Deploy
  │      │      │       │
  │      │      │       └── Only if main branch
  │      │      └── Build Docker image
  │      └── Run pytest
  └── Trigger on push/PR
```

### Best Practices

1. **Run tests on every PR**: Catch issues before merge
2. **Require passing tests**: Block merge if tests fail
3. **Deploy only from main**: Feature branches don't auto-deploy
4. **Use secrets properly**: Never expose API keys
5. **Cache dependencies**: Faster builds
6. **Notify on failure**: Know when things break

### Caching

Speed up builds:

```yaml
- uses: actions/cache@v3
  with:
    path: ~/.cache/pip
    key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
```

### Notifications

Know when builds fail:

```yaml
- name: Notify Slack
  if: failure()
  uses: 8398a7/action-slack@v3
  with:
    status: failure
    webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

## Things to Think About

- **How often should you deploy?** As often as you want, if tests pass. Daily? Hourly? Per commit?
- **What about rollbacks?** Keep previous deployments available. Roll back if something breaks.
- **What about database migrations?** Run them as part of deploy. Have a rollback plan.

## Related

- [Docker](./4.1-docker.md) - What gets deployed
- [Cloud Deployment](./4.7-cloud-deployment.md) - Where it deploys to
- [Evaluation Systems](../phase-3-advanced-patterns/3.8-evaluation-systems.md) - Test AI systems in CI

## Book References

- AI_eng.4 - Testing AI systems
