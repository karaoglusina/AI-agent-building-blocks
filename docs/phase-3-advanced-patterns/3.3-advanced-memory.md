# Advanced Memory

Basic memory stores messages. Advanced memory structures information, scores importance, consolidates redundancy, tracks preferences, and recalls specific episodes. This is how agents get genuinely personal.

## Why This Matters

A simple buffer fills up. Advanced memory keeps what matters and forgets what doesn't. It notices "I prefer remote jobs" across multiple conversations and applies that preference automatically.

For our job market analyzer, advanced memory means remembering your career goals, past searches, preferences, and even specific jobs you've discussed - creating a truly personalized experience.

## The Key Ideas

### Structured Memory

Enforce schemas on memories:

```python
class SkillMemory(BaseModel):
    skill: str
    proficiency: Literal["beginner", "intermediate", "expert"]
    years_experience: int
    source: str  # Where we learned this
    confidence: float

# Not just "user knows Python"
# But: skill="Python", proficiency="expert", years=5, confidence=0.9
```

Structured memories are queryable, validatable, and transformable.

### Importance Scoring

Not all memories are equal:

```python
def score_importance(memory) -> float:
    """0 = trivial, 1 = critical"""
    factors = {
        "contains_preference": 0.3,
        "contains_requirement": 0.3,
        "explicitly_stated": 0.2,
        "repeated_mention": 0.2
    }
    return sum(v for k, v in factors.items() if matches(memory, k))

# "I absolutely need remote work" → 0.8
# "ok, thanks" → 0.1
```

Prune low-importance memories to stay within budget.

### Memory Consolidation

Merge redundant information:

```python
# Before consolidation:
"User knows Python"
"User is a Python expert"
"User has Python experience"

# After consolidation:
"User is a Python expert with extensive experience"
```

Reduces redundancy while preserving information.

### Preference Memory

Automatically detect and store preferences:

```python
class PreferenceMemory:
    def extract_preferences(self, message: str) -> list[Preference]:
        # "I'd prefer remote, but I could consider hybrid"
        # → Preference(type="work_style", value="remote", strength="strong")
        # → Preference(type="work_style", value="hybrid", strength="weak")

    def get_active_preferences(self) -> dict:
        # Returns current preferences for search/recommendations
```

Preferences accumulate across conversations.

### Episodic Memory

Remember specific interactions:

```python
class Episode(BaseModel):
    timestamp: datetime
    summary: str
    entities: list[str]  # Jobs, companies mentioned
    outcome: str  # What happened
    sentiment: Literal["positive", "negative", "neutral"]

# "On Jan 15, we discussed the Google ML role. User was excited but
# concerned about the interview process. We scheduled a follow-up."
```

Enables "remember when we discussed...?" queries.

## What's in This Module

| Script | What it shows |
|--------|---------------|
| [01_structured_memory.py](../../modules/Phase%203%20-%20Advanced%20Patterns/3.3-advanced-memory/01_structured_memory.py) | Enforcing schemas on memories |
| [02_memory_importance.py](../../modules/Phase%203%20-%20Advanced%20Patterns/3.3-advanced-memory/02_memory_importance.py) | Scoring what to keep |
| [03_memory_consolidation.py](../../modules/Phase%203%20-%20Advanced%20Patterns/3.3-advanced-memory/03_memory_consolidation.py) | Merging redundant info |
| [04_preference_memory.py](../../modules/Phase%203%20-%20Advanced%20Patterns/3.3-advanced-memory/04_preference_memory.py) | Detecting and storing preferences |
| [05_episodic_memory.py](../../modules/Phase%203%20-%20Advanced%20Patterns/3.3-advanced-memory/05_episodic_memory.py) | Recalling specific interactions |

## Memory Architecture

```
┌─────────────────────────────────────────────┐
│          Memory Management Layer            │
│   [Importance]  [Consolidation]  [Schema]   │
├─────────────────────────────────────────────┤
│            Memory Storage Layer             │
│  [Preferences]  [Episodes]  [Facts]         │
├─────────────────────────────────────────────┤
│             Retrieval Layer                 │
│  • Semantic search                          │
│  • Timeline queries                         │
│  • Importance thresholds                    │
└─────────────────────────────────────────────┘
```

## Pattern Selection

| Pattern | Use When |
|---------|----------|
| Structured | Clear schema, need validation |
| Importance | Limited budget, lots of memories |
| Consolidation | Redundant info accumulating |
| Preference | Building personalized systems |
| Episodic | Need to recall specific events |

## Combining Patterns

Real systems often use multiple patterns:

```python
# Extract structured memories
memories = extract_structured(conversation)

# Score importance
for mem in memories:
    mem.importance = score_importance(mem)

# Store high-importance items
for mem in memories:
    if mem.importance > 0.7:
        if isinstance(mem, Preference):
            preference_store.add(mem)
        else:
            fact_store.add(mem)

# Periodically consolidate
consolidate_similar_memories()
```

## Things to Think About

- **How do you handle contradictions?** User says "I prefer remote" then "actually, office is fine." Keep both with timestamps, or update?
- **When do you surface memories?** Retrieve based on current query relevance. Don't dump everything into every prompt.
- **What's the right importance threshold?** Depends on your memory budget. Experiment with your use case.

## Related

- [Memory Patterns](../phase-2-building-ai-systems/2.7-memory-patterns.md) - Basic memory approaches
- [Multi-Agent Systems](./3.2-multi-agent-systems.md) - Shared memory across agents
- [Context Engineering](../phase-2-building-ai-systems/2.6-context-engineering.md) - Memory in context

## Book References

- AI_eng.6 - Agent memory architectures
