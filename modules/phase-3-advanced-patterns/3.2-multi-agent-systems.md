# Multi-Agent Systems

Sometimes one agent isn't enough. Complex tasks benefit from specialized agents working together - a search agent, an analysis agent, a recommendation agent - coordinated to achieve goals none could handle alone.

## Why This Matters

Single agents try to do everything. Multi-agent systems divide responsibilities. A search agent knows about vector databases. An analysis agent knows about comparison. A preference agent tracks what users want. Each does one thing well.

For our job market analyzer, multi-agent means: a coordinator that understands the query, a search agent that finds jobs, an analysis agent that compares them, and a preference agent that remembers what you like.


## Scripts in This Module

| Script | What it shows |
|--------|---------------|
| <a href="../../scripts/phase-3-advanced-patterns/3.2-multi-agent-systems/01_agent_handoff.py">01_agent_handoff.py</a> | Route to specialists based on intent |
| <a href="../../scripts/phase-3-advanced-patterns/3.2-multi-agent-systems/02_specialized_agents.py">02_specialized_agents.py</a> | Agents with focused expertise |
| <a href="../../scripts/phase-3-advanced-patterns/3.2-multi-agent-systems/03_coordinator_pattern.py">03_coordinator_pattern.py</a> | Orchestrator delegates to workers |
| <a href="../../scripts/phase-3-advanced-patterns/3.2-multi-agent-systems/04_preference_detector.py">04_preference_detector.py</a> | Extract and maintain preferences |
| <a href="../../scripts/phase-3-advanced-patterns/3.2-multi-agent-systems/05_agent_communication.py">05_agent_communication.py</a> | Inter-agent message passing |


## The Key Ideas

### Agent Handoff

Route users to the right specialist:

```python
intent = classify_intent(user_input)  # "search", "compare", "recommend"

agents = {
    "search": SearchAgent(),
    "compare": ComparisonAgent(),
    "recommend": RecommendationAgent()
}

response = agents[intent].handle(user_input)
```

Different agents for different conversation stages or domains.

### Specialized Agents

Each agent has its own capabilities and tools:

```python
class SearchAgent:
    tools = [vector_search, metadata_filter, sort_results]
    system_prompt = "You are a job search specialist..."

class AnalysisAgent:
    tools = [compare_jobs, extract_metrics, summarize_differences]
    system_prompt = "You are a job analysis specialist..."
```

Focused expertise and relevant tools.

### Coordinator Pattern

A central orchestrator decomposes tasks and delegates:

```python
# Coordinator receives complex query
query = "Find remote ML jobs, compare top 3, recommend based on my preferences"

# Plan tasks
plan = coordinator.plan(query)
# [("search", "remote ML jobs"), ("compare", "top 3"), ("recommend", "with preferences")]

# Delegate to workers
for task_type, task_details in plan:
    result = workers[task_type].execute(task_details)

# Synthesize final response
final = coordinator.synthesize(results)
```

The coordinator thinks; workers execute.

### Preference Detection

A specialized agent that extracts and maintains preferences:

```python
class PreferenceAgent:
    def detect_preferences(self, message: str) -> list[Preference]:
        """Extract preferences like 'I prefer remote' or 'salary > 100k'"""
        ...

    def apply_preferences(self, search_params: dict) -> dict:
        """Modify search based on stored preferences"""
        return {**search_params, **self.stored_preferences}
```

Runs alongside other agents, building a preference profile.

### Agent Communication

Agents share information through messages:

```python
# Search agent finds jobs
search_result = search_agent.execute("Find ML jobs")

# Pass to analysis agent
analysis_input = Message(
    from_agent="search",
    to_agent="analysis",
    content="analyze these",
    data=search_result.jobs
)

analysis_result = analysis_agent.process(analysis_input)
```

Structured communication enables collaboration.

## Design Patterns

### When to Use Single vs Multi-Agent

| Scenario | Approach |
|----------|----------|
| Simple, focused task | Single agent |
| Multiple distinct capabilities | Multi-agent |
| Long conversations with topic shifts | Agent handoff |
| Complex multi-step tasks | Coordinator + workers |
| Personalization over time | Preference agent |

### Coordination Strategies

| Strategy | Description | Best For |
|----------|-------------|----------|
| Intent-based routing | Route by detected intent | Distinct conversation modes |
| Coordinator | Central planner delegates | Complex multi-step tasks |
| Pipeline | Fixed sequence of agents | Predictable workflows |
| Collaborative | Agents discuss and refine | Creative tasks |

## Things to Think About

- **How do agents share context?** Through explicit messages, shared memory, or database queries.
- **What happens when agents disagree?** The coordinator resolves conflicts, or you escalate to the user.
- **When is multi-agent overkill?** For simple tasks, one agent is simpler and faster. Add agents when complexity justifies it.

## Related

- [Agent Orchestration](../phase-2-building-ai-systems/2.5-agent-orchestration.md) - Single agent basics
- [Advanced Agent Patterns](./3.1-advanced-agent-patterns.md) - Making individual agents smarter
- [Advanced Memory](./3.3-advanced-memory.md) - Shared memory across agents

## Book References

- AI_eng.6 - Multi-agent systems
- AI_eng.10.5 - Orchestration patterns
